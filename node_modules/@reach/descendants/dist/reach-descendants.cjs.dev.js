"use strict";
/**
  * @reach/descendants v0.18.0
  *
  * Copyright (c) 2018-2022, React Training LLC
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/reach-descendants.tsx
var reach_descendants_exports = {};
__export(reach_descendants_exports, {
  DescendantProvider: () => DescendantProvider,
  createDescendantContext: () => createDescendantContext,
  useDescendant: () => useDescendant,
  useDescendantKeyDown: () => useDescendantKeyDown,
  useDescendants: () => useDescendants,
  useDescendantsInit: () => useDescendantsInit
});
module.exports = __toCommonJS(reach_descendants_exports);
var React = __toESM(require("react"));
var import_utils = require("@reach/utils");
function createDescendantContext(name, initialValue = {}) {
  const descendants = [];
  let ctx = React.createContext(__spreadValues({
    descendants,
    registerDescendant: () => import_utils.noop
  }, initialValue));
  ctx.displayName = name;
  return ctx;
}
function useDescendant(descendant, context, indexProp) {
  let forceUpdate = (0, import_utils.useForceUpdate)();
  let { registerDescendant, descendants } = React.useContext(context);
  let index = indexProp != null ? indexProp : descendants.findIndex((item) => item.element === descendant.element);
  (0, import_utils.useIsomorphicLayoutEffect)(() => {
    if (!descendant.element)
      forceUpdate();
    return registerDescendant(__spreadProps(__spreadValues({}, descendant), { index }));
  }, [
    descendant,
    forceUpdate,
    index,
    registerDescendant,
    ...Object.values(descendant)
  ]);
  return index;
}
function useDescendantsInit() {
  return React.useState([]);
}
function useDescendants(ctx) {
  return React.useContext(ctx).descendants;
}
function DescendantProvider({
  context: Ctx,
  children,
  items,
  set
}) {
  let registerDescendant = React.useCallback((_a) => {
    var _b = _a, {
      element,
      index: explicitIndex
    } = _b, rest = __objRest(_b, [
      "element",
      "index"
    ]);
    if (!element)
      return import_utils.noop;
    set((items2) => {
      if (explicitIndex != null && explicitIndex !== -1) {
        return insertAt(items2, __spreadValues({ element, index: explicitIndex }, rest), explicitIndex);
      }
      if (items2.length === 0) {
        return [__spreadProps(__spreadValues({}, rest), { element, index: 0 })];
      }
      if (true) {
        if (items2.find((item) => item.element === element)) {
          console.warn("[reach-ui]: `useDescendant` was called with an element that was already registered.\n\nIf you are using the `@reach/descendants` package directly, make sure to only register descendants once. Registering a descendant more than once will lead to bugs in your app.\n\nIf you are using another `reach-ui` package, this is probably our bug!\n\nTo report a bug, open a new issue:\n\n  https://github.com/reach/reach-ui/issues/new?assignees=&labels=&template=Bug_report.md\n\nIMPORTANT: this check will only run in the development build, so if you see this warning please be aware that your app may crash when deployed.");
          return updateIndices(items2);
        }
      }
      let index = findDOMIndex(items2, element);
      let newItems;
      if (index === -1) {
        newItems = [
          ...items2,
          __spreadProps(__spreadValues({}, rest), { element, index: items2.length })
        ];
      } else {
        newItems = insertAt(items2, __spreadProps(__spreadValues({}, rest), { element, index }), index);
      }
      return newItems;
    });
    return () => {
      if (!element)
        return;
      set((items2) => items2.filter((item) => element !== item.element));
    };
  }, []);
  return /* @__PURE__ */ React.createElement(Ctx.Provider, {
    value: React.useMemo(() => {
      return {
        descendants: items,
        registerDescendant
      };
    }, [items, registerDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  let { descendants } = React.useContext(context);
  let {
    callback,
    currentIndex,
    filter,
    key = "index",
    orientation = "vertical",
    rotate = true,
    rtl = false
  } = options;
  return function handleKeyDown(event) {
    if (![
      "ArrowDown",
      "ArrowUp",
      "ArrowLeft",
      "ArrowRight",
      "PageUp",
      "PageDown",
      "Home",
      "End"
    ].includes(event.key)) {
      return;
    }
    let index = currentIndex != null ? currentIndex : -1;
    let selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (!selectableDescendants.length) {
      return;
    }
    let selectableIndex = selectableDescendants.findIndex((descendant) => descendant.index === currentIndex);
    function getNextOption() {
      let atBottom = index === getLastOption().index;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      let atTop = index === getFirstOption().index;
      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        let prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        let first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        let last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, element) {
  if (!element)
    return -1;
  if (!items.length)
    return -1;
  let length = items.length;
  while (length--) {
    let currentElement = items[length].element;
    if (!currentElement)
      continue;
    if (isElementPreceding(currentElement, element)) {
      return length + 1;
    }
  }
  return -1;
}
function insertAt(array, item, index) {
  if (index == null || !(index in array)) {
    return [...array, item];
  }
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function updateIndices(items) {
  return items.sort((a, b) => !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1).map((item, index) => __spreadProps(__spreadValues({}, item), { index }));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DescendantProvider,
  createDescendantContext,
  useDescendant,
  useDescendantKeyDown,
  useDescendants,
  useDescendantsInit
});
//# sourceMappingURL=reach-descendants.cjs.dev.js.map